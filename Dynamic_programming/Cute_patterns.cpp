/*
Компания BrokenTiles планирует заняться выкладыванием во дворах у состоятельных клиентов узор из черных и белых плиток,
каждая из которых имеет размер 1×1 метр.
Известно, что дворы всех состоятельных людей имеют наиболее модную на сегодня форму прямоугольника M×N метров.

Однако при составлении финансового плана у директора этой организации появилось целых две серьезных проблемы:
во первых, каждый новый клиент очевидно захочет, чтобы узор, выложенный у него во дворе,
отличался от узоров всех остальных клиентов этой фирмы, а во вторых, этот узор должен быть симпатичным.

Как показало исследование, узор является симпатичным, если в нем нигде не встречается квадрата 2×2 метра, 
полностью покрытого плитками одного цвета.

Для составления финансового плана директору необходимо узнать, сколько клиентов он сможет обслужить, 
прежде чем симпатичные узоры данного размера закончатся. Помогите ему!
*/

#include <iostream>
#include <vector>

bool check(size_t m1, size_t m2, int64_t n) {
    for (size_t i = 0; i < n - 1; ++i) {
        int bit1_m1 = (m1 >> i) % 2;
        int bit1_m2 = (m2 >> i) % 2;
        int bit2_m1 = (m1 >> (i + 1)) % 2;
        int bit2_m2 = (m2 >> (i + 1)) % 2;

        if (bit1_m1 == bit1_m2 && bit2_m1  == bit2_m2 && bit1_m1 == bit2_m1) {
            return false;
        }
    }
    return true;
}

int64_t get_count_pattern(int64_t n, int64_t m) {
    if (n > m) std::swap(n, m);

    int64_t pow = 1 << n;
    std::vector<std::vector<int64_t>> dp(m, std::vector<int64_t> (pow + 1, 0));
    
    //dp[i][j] j - маски, i - размер квадрата (минимальный)
    //в dp лежит количество симпотичных для данный масски и размера    

    for (size_t i = 0; i < pow; ++i) {
        dp[0][i] = 1;
    }

    for (size_t i = 1; i < m; ++i) {
        for (size_t mask1 = 0; mask1 < pow; ++mask1) {
            for (size_t mask2 = 0; mask2 < pow; ++mask2) {
                if (check(mask1, mask2, n)) dp[i][mask1] += dp[i - 1][mask2];
            }
        }
    }
    int64_t answer = 0;

    for (size_t i = 0; i < pow; ++i) {
        answer += dp[m - 1][i];
    }
    return answer;
}

int main() {
    int64_t m, n;
    std::cin >> m >> n;
    
    std::cout << get_count_pattern(n, m);
}

